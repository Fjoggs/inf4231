--- For lectures. A simple protocol which uses sequence numbers and
---  acknowledgments to achieve reliable and ordered communication
---  through an unreliable (i.e., lossy and duplicating) and
---  unordered transmission medium.

--- The protocol does not terminate.

--- MY CODE IS WRITTEN ALONGSIDE THIS MODULE THAT WAS GIVEN IN THE LECTURES.

load full-maude

--- First the message types:

(omod MESSAGES is protecting STRING .
    sort MsgContent .
    subsort String < MsgContent .   --- our "main" messages are just strings!
    op ack : -> MsgContent [ctor] . --- acknowledgment message  

    --- sequence number wrapper:
    msg _withSeqNo_ : MsgContent Nat -> Msg .

    --- the final envelope: sender and receiver
    msg msg_from_to_ : Msg Oid Oid -> Msg .
endom)

--- Model the possibilities for loss and duplication of messages:

(omod UNRELIABILITY is protecting MESSAGES .
    var M : Msg .
    vars O O' : Oid .

    --- Loss of a message of the given kind:
    rl [messageLoss] :
        msg M from O to O'  =>  none .

    --- Duplication of swimming messages:
    rl [duplicateMsg] :
        msg M from O to O'  =>  (msg M from O to O')  (msg M from O to O') .
endom)

--- A module for LISTS of Strings:
(fmod STRING-LIST is protecting STRING .
    sort StringList .
    subsort String < StringList .
    op nil : -> StringList [ctor] .
    op _++_ : StringList StringList -> StringList [ctor assoc id: nil] .
    op listSize : StringList -> Nat .
    op _erPrefiksAv_ : StringList StringList -> Bool .
        
    var S S' : String .
    var SL SL' : StringList .

    eq listSize(nil) = 0 .
    eq listSize(S ++ SL) = 1 + listSize(SL) .

    eq nil erPrefiksAv nil = true .
    eq nil erPrefiksAv (S' ++ SL') = true .
    eq (S ++ SL) erPrefiksAv nil = false .
    eq (S ++ SL) erPrefiksAv (S' ++ SL') = if S == S' then SL erPrefiksAv SL' else false fi . 

endfm)


(fmod WINDOW-LIST is protecting MESSAGES .
    sort windowList .
    subsort Msg < windowList .
    op empty : -> Msg [ctor] .
    op _--_ : windowList windowList -> windowList [ctor assoc id: empty] .
    op delete : windowList Nat -> windowList .

    vars N N' : Nat .
    vars M M' : Msg .
    vars S S' : String .
    var WL : windowList .

    op wSize : windowList -> Nat .
    op isPresent? : windowList Nat -> Bool .
    op remove : windowList Nat -> windowList .
    op add : windowList Msg -> windowList .

    eq wSize(empty) = 0 .
    eq wSize(M WL) = 1 + wSize(WL) .

    eq isPresent?(empty, N) = true .
    eq isPresent?((S withSeqNo N) -- WL, N') = if N == N' then false else isPresent?(WL, N') fi  .

    eq remove(empty, N) = empty .
    eq remove(empty -- WL, N) = empty .
    eq remove((S withSeqNo N) -- WL, N') = if N < N' then remove(WL, N') else (S withSeqNo N) -- WL fi .

    eq add(empty, M) = M .
    eq add((S withSeqNo N) -- WL, (S' withSeqNo N')) = if N > N' then (S' withSeqNo N') -- (S withSeqNo N) -- WL else (S withSeqNo N) -- add(WL, (S' withSeqNo N')) fi .
endfm)

--- Here comes the actual protocol:
(omod PROTOCOL-1 is 
  including STRING-LIST .
  including MESSAGES .
  including UNRELIABILITY .
  including WINDOW-LIST .




  --- Sender protocol:
    class Sender | msgsToSend : StringList,   --- messages not sent yet
                   currentMsg : StringList,   --- current string, or nil
                   currentSeqNo : Nat,        --- seq no to current msg 
                   receiver : Oid ,           --- receiver address        
                   window : windowList,
                   windowSize : Nat,
                   nbuffered : Nat,
                   ack : windowList,
                   lastSent : Nat .


    vars N N' N'' N''' : Nat .
    var NZ : NzNat .
    vars O O' : Oid .
    vars S S' : String .
    var SL : StringList .
    vars WL WL' WL'' : windowList .
    var M : Msg .
    
    rl [start] :
        < O : Sender | msgsToSend : S ++ SL, currentSeqNo : 0, lastSent : 0 >
        =>
        < O : Sender | msgsToSend : SL, currentMsg : S, currentSeqNo : 1, lastSent : 1 > .

    crl [sendCurrentMsg] :      
        < O : Sender | msgsToSend : S' ++ SL, currentMsg : S, currentSeqNo : N, lastSent : N', windowSize : N'', nbuffered : N''', receiver : O', window : WL, ack : WL' >  
        =>
        < O : Sender | msgsToSend : SL, currentMsg : S', window : WL' -- (S withSeqNo N'), ack : WL' -- (S withSeqNo N') , lastSent : N' + 1, nbuffered : N''' + 1 >
        msg (S withSeqNo N') from O to O' 
        if N'' > N''' /\ S =/= nil .
    
    crl [sendLast] :      
        < O : Sender | msgsToSend : nil, currentMsg : S, currentSeqNo : N, lastSent : N', windowSize : N'', nbuffered : N''', receiver : O', window : WL, ack : WL' >  
        =>
        < O : Sender | msgsToSend : nil, currentMsg : nil, window : WL' -- (S withSeqNo N'), ack : WL' -- (S withSeqNo N') , lastSent : N' + 1, nbuffered : N''' + 1 >
        msg (S withSeqNo N') from O to O' 
        if N'' > N''' .

  
    crl [resendWindow] :
        < O : Sender | receiver : O', window : WL -- M -- WL' >  
        =>
        < O : Sender | >
        msg M from O to O' 
        if M =/= empty .
     
    rl [receiveCurrentAckNotLast] :
        (msg (ack withSeqNo N) from O' to O)
        < O : Sender | currentSeqNo : N, ack : WL -- (S' withSeqNo N) -- WL', window : WL'', nbuffered : N'  >
        =>
        < O : Sender | currentSeqNo : N + 1 + wSize(WL), ack : WL', window : WL', nbuffered : wSize(WL') > .

    rl [receiveAckLast] :
        (msg (ack withSeqNo N) from O' to O)
        < O : Sender | currentSeqNo : N, msgsToSend : nil, ack : (S withSeqNo N) -- WL', window : WL'', nbuffered : N' >
        =>
        < O : Sender | currentSeqNo : N + 1, currentMsg : nil, ack : WL', window : WL', nbuffered : wSize(WL')  > .

    crl [rcvTooOldAck] :
        (msg (ack withSeqNo N) from O' to O)
        < O : Sender | currentSeqNo : N' > 
        =>
        < O : Sender | > 
        if N < N' .
    
  
    --- Receiver protocol:
    
    class Receiver | greatestSeqNoRcvd : Nat, 
                     sender : Oid, 
                     msgsRcvd : StringList,
                     window : windowList,
                     windowSize : Nat,
                     nbuffered : Nat .
    --- Note: the latter attribute is NOT a part of the protocol,
    ---       just added for analysis purposes.
    var SL : StringList .

    op save : StringList windowList Nat -> StringList .

    eq save(SL, empty, N') = SL .
    eq save(SL, (S withSeqNo N) -- M, N') = if N <= N' then save((SL ++ S), M, N) else SL fi .

    --- send ack's, only when seqNo > 0:
    rl [sendAck] :
        < O : Receiver | greatestSeqNoRcvd : NZ, sender : O' >
        =>
        < O : Receiver | >
        msg (ack withSeqNo NZ) from O to O' .
   
    --- receive NEXT new packet:
    rl [rcvNewPacket] :
        (msg (S withSeqNo s N) from O' to O)
        < O : Receiver | greatestSeqNoRcvd : N, msgsRcvd : SL, window : WL, nbuffered : N' >
        =>
        < O : Receiver | greatestSeqNoRcvd : (listSize(save((SL ++ S), WL, N))), window : remove(WL, N), msgsRcvd : save((SL ++ S), WL, N), nbuffered : wSize(remove(WL, N)) > .

    crl [rcvNewPacketFuture] :
        (msg (S withSeqNo N) from O' to O)
        < O : Receiver | greatestSeqNoRcvd : N', window : WL, nbuffered : N'', windowSize : N''' >
        =>
        < O : Receiver | window : add(WL, (S withSeqNo N)), nbuffered : N'' + 1  >
        if N > N' + 1 /\ N'' < N''' /\ isPresent?(WL, (N)) .

    --- receive/ignore  a packet with an *old* sequence number:
    crl [rcvOldPacket] :
        (msg (S withSeqNo N) from O' to O)
        < O : Receiver | greatestSeqNoRcvd : N' >
        =>
        < O : Receiver | >
        if N =/= s N' .
endom)

--- EXCERCISE 2

--- Define some suitable initial states:
(omod TEST-PROTOCOL-1 is including PROTOCOL-1 .
    subsort String < Oid .

    op init : Nat  -> Configuration .   --- a suitable initial state

    var N : Nat .

    eq init(N) =
        < "Sender" : Sender | msgsToSend : "Obligen" ++ "er" ++ 
                                "utrolig" ++ "spennende" ++ "og" ++ "inspirerende",
                                currentMsg : nil,
                                currentSeqNo : 0,
                                receiver : "Receiver",
                                window: empty,
                                windowSize: N,
                                ack : empty,
                                lastSent : 0 >
        < "Receiver" : Receiver | greatestSeqNoRcvd : 0, msgsRcvd : nil,
                                sender : "Sender", 
                                window : empty,
                                windowSize : N,
                                nbuffered : 0 > .
endom)

--- EXCERCISE 3
